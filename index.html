<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<style>
html,
body {
  height: 100%;
  margin: 0;
  overflow: hidden;
}
#visarea {
  position: fixed;
  left: 0px;
  right: 0px;
  top: 0px;
  bottom: 0px;
}
</style>
<body>
<div id="visarea"></div>
<button onclick="modeNegativeFace();">Negative Face</button>
<button onclick="modePositiveFace();">Positive Face</button>
<button onclick="modeTSST();">TSST</button>
<button onclick="modeEMA();">EMA</button>
<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script>

var mode = "TSST";
curvals = [];

var drawlinePlot = function(draw=true,curve1=null){
    var vis = $("#visarea")
    vis.empty();
    
    var margin = {top: 50, right: 40, bottom: 60, left: 75},
        width = visarea.clientWidth,
        height = visarea.clientHeight,
        gheight = height - margin.top - margin.bottom,
        gwidth = width - margin.left - margin.right;

    var x = d3.scaleLinear()
        .domain([0, 1])
        .range([0, gwidth])
    
    var y = d3.scaleLinear()
        .domain([0, 1])
        .range([gheight, 0])
    
    var xticklabs = ["Start","End"]
    var yticklabs = ["Low","High"]
    
    var xAxis = d3.axisBottom(x)
                .ticks(1)
                .tickFormat(function(d,i){ return xticklabs[i] });
    var yAxis = d3.axisLeft(y)
                .ticks(1)
                .tickFormat(function(d,i){ return yticklabs[i] });
    
    var svg = d3.select("#visarea").append("svg")
        .attr("width",width)
        .attr("height",height)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    
    svg.append("rect")
        .attr("width",width)
        .attr("height",height)
        .attr("fill","white");
    
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + gheight + ")")
        .call(xAxis)
    
    svg.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(0,0)")
        .call(yAxis)
    
    d3.selectAll(".tick")
        .attr("font-size",16);

    if (mode == "TSST") {
      svg.append("rect")
          .attr("width",gwidth*0.1)
          .attr("x", 1.0)
          .attr("height",gheight)
          .attr("fill","#bef");
      svg.append("text")
          .style("fill","#659")
          .attr("text-anchor", "middle")
          .attr("font-size",14)
          .attr("x", gwidth * 0.05)
          .attr("y", gheight * 0.7)
          .text("Prep");

      svg.append("rect")
          .attr("width", gwidth*0.15)
          .attr("x", gwidth*0.1)
          .attr("height", gheight)
          .attr("fill","#feb");
      svg.append("text")
          .style("fill","#659")
          .attr("text-anchor", "middle")
          .attr("font-size",14)
          .attr("x", gwidth * 0.175)
          .attr("y", gheight * 0.7)
          .text("Speech");

      svg.append("rect")
          .attr("width",gwidth*0.1)
          .attr("x", gwidth*0.25)
          .attr("height",gheight)
          .attr("fill","#fbb");
      svg.append("text")
          .style("fill","#966")
          .attr("text-anchor", "middle")
          .attr("font-size",14)
          .attr("x", gwidth * 0.3)
          .attr("y", gheight * 0.7)
          .text("Math");

      svg.append("rect")
          .attr("width",gwidth*0.25)
          .attr("x", gwidth*0.75)
          .attr("height",gheight)
          .attr("fill","#bbb");
      svg.append("text")
          .style("fill","#666")
          .attr("text-anchor", "middle")
          .attr("font-size",14)
          .attr("x", gwidth * 0.88)
          .attr("y", gheight * 0.7)
          .text("Rating myself");
    }
    
    svg.append("text")
        .attr("class", "xlabel")
        .attr("text-anchor", "middle")
        .attr("font-size",24)
        .attr("x", gwidth/2)
        .attr("y", gheight* 1.04)
        .text("Time")
    
    svg.append("text")
        .attr("class", "ylabel")
        .attr("text-anchor", "middle")
        .attr("font-size",24)
        .attr("x", -(gheight)/2)
        .attr("y", -gwidth * 0.01)
        .attr("transform", "rotate(-90)")
        .text("Intensity");
    
    if(draw){
        
        var line = d3.line()
            .curve(d3.curveBasis);
        
        var xmin = 0;
        svg.call(d3.drag()
                .container(function() { return this; })
                .subject(function() { var p = [d3.event.x, d3.event.y]; return [p, p]; })
                .on("start", dragstarted));
        function dragstarted() {
          var valpos = d3.event.x>0 & d3.event.x<(width-margin.left-margin.right) & d3.event.y>0 & d3.event.y<(height-margin.bottom-margin.top);
          if(valpos & draw){
              var d = d3.event.subject,
                  active = svg.append("path").datum(d)
                    .attr("fill","none")
                    .attr("stroke","#0066ff")
                    .attr("stroke-width","5px")
                    .attr("stroke-linejoin","round")
                    .attr("stroke-linecap","round"),
                  x0 = d3.event.x,
                  y0 = d3.event.y;
              curvals.push({"x":x0,"y":y0});

              d3.event.on("drag", function() {
                var x1 = d3.event.x,
                    y1 = d3.event.y,
                    dx = x1 - x0,
                    dy = y1 - y0;
                var valpos = x1>xmin & x1<(width-margin.left-margin.right) & y1>0 & y1<(height-margin.bottom-margin.top);
                if (valpos){
                    curvals.push({"x":x1,"y":y1});
                    xmin = x1;
                    if (dx * dx + dy * dy > 10) d.push([x0 = x1, y0 = y1]);
                    else d[d.length - 1] = [x1, y1];
                    active.attr("d", line);
                }
              });
              
              d3.event.on("end", function(){
                if (curvals.length>2){
                    draw = false;
                    // TODO: Here is where we prompt the user to say "DONE"
                    curvals = normDrawing(curvals,height-margin.top-margin.bottom);
                    drawlinePlot(false,curvals);
                } else {
                    curvals = [];
                    drawlinePlot();
                }
              });
          }
        }
    } else {
        
        var line = d3.line()
                .x(function(d) {return x(d["x"]); })
                .y(function(d) {return y(d["y"]); })
                .curve(d3.curveBasis);
        
        if (curve1 != null){

            svg.append("path").datum(curve1)
                .attr("fill","none")
                .attr("stroke","#0066aa")
                .attr("stroke-width","7px")
                .attr("stroke-linejoin","round")
                .attr("stroke-linecap","round")
                .attr('d',line);
        }
        
    }

    svg.on("click", function() {
        if (!draw) {
            draw = true;
            curvals = [];
            drawlinePlot();
        }
    });
}

var normDrawing = function(drawn,ymax){
    cvxMax = d3.max(drawn, function(d) {return d.x});
    cvxMin = d3.min(drawn, function(d) {return d.x});
    cvyMax = d3.max(drawn, function(d) {return d.y});
    cvyMin = d3.min(drawn, function(d) {return d.y});
    for (var i = 0; i < drawn.length; i ++){
        drawn[i]["x"] = (drawn[i]["x"]-cvxMin)/(cvxMax-cvxMin);
        drawn[i]["y"] = 1-(drawn[i]["y"]/ymax);
    }
    
    var idrawn = [];
    for (var i = 0; i < (drawn.length-1); i ++){
        var fx = d3.interpolateNumber(drawn[i]["x"],drawn[i+1]["x"])
        var fy = d3.interpolateNumber(drawn[i]["y"],drawn[i+1]["y"])
        for (var j=0; j<100; j ++){
            idrawn.push({"x":fx(j/100),"y":fy(j/100)});
        }
    }

    return idrawn;
}

function redraw(){
    drawlinePlot();
}

redraw();

window.addEventListener("resize", redraw);

</script>
</body>
</html>
